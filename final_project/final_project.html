<doctype html>
<html>
<head>
<title>Final Project</title>
<script type="text/javascript" id="includedscript" src="drawers.js"></script>
<script type="text/javascript" id="includedscript" src="entities.js"></script>
<script type="text/javascript" id="includedscript" src="utils.js"></script>
<script type="text/javascript" id="includedscript" src="skybox.js"></script>


<script type="text/javascript">

var timestep = 20.0;

const transZmin = 1.001;
const transZmax = 10;

var canvas, gl, sim, world, crtr;
var perspectiveMatrix;	// perspective projection matrix
var environmentTexture;
var viewRotX=0, viewRotZ=0, transZ=3;

var boxDrawer;

var lights = [
	{
		position:  [ 0, 0, 1000 ],

		intensity: [ 1, 1, 1 ]
	}
];

function InitScene()
{
  var trans = GetTrans();
  var mvp = MatrixMult( perspectiveMatrix, trans.worldToCam );
  boxDrawer  = new BoxDrawer();
  world = new World(boxDrawer, mvp, null, 10.0, null);
  world.drawer.setMesh(getBoxMesh(5,5,-1,-5,-5,-1), null);
  
  sim = new SimulationControl(world, timestep);
}


// Called once to initialize
function InitWebGL()
{
	// Initialize the WebGL canvas

	canvas = document.getElementById("canvas");
	canvas.oncontextmenu = function() {return false;};
	gl = canvas.getContext("webgl", {antialias: false, depth: true});	// Initialize the GL context

	if (!gl) {
		alert("Unable to initialize WebGL. Your browser or machine may not support it.");
		return;

	}
	
	// Initialize settings

	gl.clearColor(0,0,0,0);
	gl.enable(gl.DEPTH_TEST);
	
	InitEnvironmentMap();		

  //background.init();

  UpdateCanvasSize();
	
  InitScene();
  

}

// Called every time the window size is changed.
function UpdateCanvasSize()
{

	canvas.style.width  = "100%";
	canvas.style.height = "100%";
	const pixelRatio = window.devicePixelRatio || 1;

	canvas.width  = pixelRatio * canvas.clientWidth;
	canvas.height = pixelRatio * canvas.clientHeight;
	const width  = (canvas.width  / pixelRatio);

	const height = (canvas.height / pixelRatio);
	canvas.style.width  = width  + 'px';
	canvas.style.height = height + 'px';

	gl.viewport( 0, 0, canvas.width, canvas.height );
	UpdateProjectionMatrix();
}

function UpdateProjectionMatrix()
{

	const fov = 60;
	var r = canvas.width / canvas.height;
	var n = 0.1;

	const min_n = 0.001;
	if ( n < min_n ) n = min_n;
	var f = transZmax*100;

	var ff = Math.PI * fov / 180;
	var tant_2 = Math.tan( ff/2 );
	var s = 1 / tant_2;

	perspectiveMatrix = [
		s/r, 0, 0, 0,
		0, s, 0, 0,

		0, 0, -(n+f)/(f-n), -1,
		0, 0, -2*n*f/(f-n), 0
	];

	
	screenQuad.init(fov,(n+f)/2);
	//background.updateProj();

}

function GetTrans()
{

	function dot(a,b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }

	var cz = Math.cos( viewRotZ );

	var sz = Math.sin( viewRotZ );
	var cx = Math.cos( viewRotX );
	var sx = Math.sin( viewRotX );


	var z = [ cx*sz, -cx*cz, sx ];
	var c = [ z[0]*transZ, z[1]*transZ, z[2]*transZ ];	

	var xlen = Math.sqrt( z[0]*z[0] + z[1]*z[1] );
	var x = [ -z[1]/xlen, z[0]/xlen, 0 ];
	var y = [ z[1]*x[2] - z[2]*x[1], z[2]*x[0] - z[0]*x[2], z[0]*x[1] - z[1]*x[0] ];

	
	var worldToCam = [
		x[0], y[0], z[0], 0,

		x[1], y[1], z[1], 0,
		x[2], y[2], z[2], 0,
		-dot(x,c), -dot(y,c), -dot(z,c), 1,

	];
	var camToWorld = [
		x[0], x[1], x[2], 0,

		y[0], y[1], y[2], 0,
		z[0], z[1], z[2], 0,
		c[0], c[1], c[2], 1

	];
	return { camToWorld:camToWorld, worldToCam:worldToCam };
}

// This is the main function that handled WebGL drawing
function DrawScene()

{
	gl.flush();

	// Clear the screen and the depth buffer.
	gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

  var trans = GetTrans();
  var mvp = MatrixMult( perspectiveMatrix, trans.worldToCam );

	// Rasterization
	//background.draw( trans );
  world.setPosition(mvp);
	world.drawWorld();

}

// Multiplies two matrices and returns the result A*B.
// The arguments A and B are arrays, representing column-major matrices.
function MatrixMult( A, B )

{
	var C = [];
	for ( var i=0; i<4; ++i ) {

		for ( var j=0; j<4; ++j ) {
			var v = 0;
			for ( var k=0; k<4; ++k ) {

				v += A[j+4*k] * B[k+4*i];
			}
			C.push(v);

		}
	}
	return C;

}

window.onload = function() {

	InitWebGL();
	canvas.zoom = function( s ) {
		transZ *= s/canvas.height + 1;

		if ( transZ < transZmin ) transZ = transZmin;
		if ( transZ > transZmax ) transZ = transZmax;
		UpdateProjectionMatrix();

		DrawScene();
	}
	canvas.onwheel = function() { canvas.zoom(0.3*event.deltaY); }

	canvas.onmousedown = function() {
		var cx = event.clientX;
		var cy = event.clientY;

		if ( event.ctrlKey ) {
			canvas.onmousemove = function() {
				canvas.zoom(5*(event.clientY - cy));

				cy = event.clientY;
			}
		} else {

			canvas.onmousemove = function() {
				viewRotZ += (cx - event.clientX)/canvas.width*5;
				viewRotX -= (cy - event.clientY)/canvas.height*5;

				cx = event.clientX;
				cy = event.clientY;
				const eps = 0.01;

				if ( viewRotX < -0.1 ) viewRotX = -0.1;
				if ( viewRotX > Math.PI/2 - eps ) viewRotX = Math.PI/2 - eps;
				UpdateProjectionMatrix();

				DrawScene();
			}
		}

	}
	canvas.onmouseup = canvas.onmouseleave = function() {
		canvas.onmousemove = null;

	}
	
	DrawScene();

};

function WindowResize()

{
	UpdateCanvasSize();
	DrawScene();

}

function UseEnvironmentMap( param )

{
	gl.bindTexture( gl.TEXTURE_CUBE_MAP, param.checked ? environmentTexture : null );
	DrawScene();

}


function NewScene()
{
	InitScene();
	DrawScene();
}


///////////////////////////////////////////////////////////////////////////////////
</script>

<style>
html {
	color: white;
	background-color: black;
	font-family: Arial;
	overflow: hidden;
}
body {
	padding: 0;
	margin: 0;
}

input[type=button] {
	width: 100%;
	min-width: 9em;
}
#canvas {
	display: block;
	position: absolute;
	top:  0;
	left: 0;
	width:  100%;
	height: 100%;
}
#canvas-div {
	position: relative;
}
.sel {
	cursor: hand;
}
#controls-div {
	vertical-align: top;
	background-color: #333;
	overflow: auto;
}
#controls {
	padding: 1em;
}
.control-group {
	position: relative;
	max-width: 12em;
}
.control {
	padding: 0.2em;
}
.control-x {
	display: none;
}

@media (orientation: landscape) {
	#canvas-div {
		display: inline-block;
		width:  calc(100% - 14em);
		height: 100%;
	}
	#controls-div {
		display: inline-block;
		width:   14em;
		height: 100%;
	}
	.control-group {
		overflow: hidden;
	}
	.control-group ~ .control-group {
		margin-top: 1em;
	}
	#texture-img {
		width: 100%;
		height: auto;
	}
}
@media (orientation: portrait) {
	#canvas-div {
		width:  100%;
		height: calc(100% - 20em);
	}
	#controls-div {
		width:  100%;
		height: 20em;
	}
	.control-group {
		display: inline-block;
		vertical-align: top;
	}
	.control-group ~ .control-group {
		margin-left: 2em;
	}
	#texture-img {
		width: auto;
		height: 5em;
	}
}
</style>

</head>
<body onresize="WindowResize()">
<div id="canvas-div"><canvas id="canvas"></canvas></div><div id="controls-div">
<div id="controls">
<div class="control-group">
<div class="control"><input type="button" value="Start Simulation" onclick="sim.toggleSimulation(this, timestep)"></div>
</div>
</div>
</div>
</div>
</body>
</html>
