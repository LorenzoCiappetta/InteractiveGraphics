<doctype html>
<html>
<head>
<title>Final Project</title>
<script type="text/javascript" id="includedscript" src="drawers.js"></script>
<script type="text/javascript" id="includedscript" src="entities.js"></script>

<!-- to render the background --> 
<script id="raytraceVS" type="x-shader/x-vertex">
attribute vec3 p;
uniform mat4 proj;
uniform mat4 c2w;
varying vec3 ray_pos;
varying vec3 ray_dir;
void main()
{
    gl_Position = proj * vec4(p,1);
	vec4 rp = c2w * vec4(0,0,0,1);
	ray_pos = rp.xyz;
	vec4 rd = c2w * vec4(p,1);
	ray_dir = rd.xyz - ray_pos;
}
</script>

<!-- to render the background -->
<script id="envFS" type="x-shader/x-fragment">
precision mediump float;
varying vec3 ray_dir;
uniform samplerCube envMap;
void main()
{
	gl_FragColor = textureCube( envMap, ray_dir.xzy );
}

</script>

<script type="text/javascript">

const transZmin = 1.001;
const transZmax = 10;

var canvas, gl, world, crtr;
var perspectiveMatrix;	// perspective projection matrix
var environmentTexture;
var viewRotX=0, viewRotZ=0, transZ=3;

var boxDrawer;

var lights = [
	{
		position:  [ 0, 0, 1000 ],

		intensity: [ 1, 1, 1 ]
	}
];

var screenQuad = {
	init( fov, z )

	{
		if ( ! this.vbuf ) this.vbuf = gl.createBuffer();
		const r = canvas.width / canvas.height;

		const ff = Math.PI * fov / 180;
		const tant_2 = Math.tan( ff/2 );
		const y = z * tant_2;

		const x = y * r;
		const rtp = [
			-x, -y, -z,

			 x, -y, -z,
			 x,  y, -z,
			-x, -y, -z,

			 x,  y, -z,
			-x,  y, -z,
		];

		gl.bindBuffer(gl.ARRAY_BUFFER, this.vbuf);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(rtp), gl.STATIC_DRAW);
	},

	draw( prog, trans )
	{
		gl.useProgram( prog );

		gl.uniformMatrix4fv( gl.getUniformLocation( prog, 'c2w' ), false, trans.camToWorld );
		gl.bindBuffer( gl.ARRAY_BUFFER, this.vbuf );
		var p = gl.getAttribLocation ( prog, 'p' );

		gl.vertexAttribPointer( p, 3, gl.FLOAT, false, 0, 0 );
		gl.enableVertexAttribArray( p );
		gl.drawArrays( gl.TRIANGLES, 0, 6 );

	}
};

var background = {
	init()
	{

		this.prog = InitShaderProgramFromScripts( 'raytraceVS', 'envFS' );
	},
	updateProj()
	{
		gl.useProgram( this.prog );
		gl.uniformMatrix4fv( gl.getUniformLocation( this.prog, 'proj' ), false, perspectiveMatrix );

	},
	draw( trans )
	{

		gl.depthMask( false );
		screenQuad.draw( this.prog, trans );
		gl.depthMask( true );

	}
};

function InitScene()
{
  var trans = GetTrans();
  var mvp = MatrixMult( perspectiveMatrix, trans.worldToCam );
  boxDrawer  = new BoxDrawer();
  world = new World(boxDrawer, mvp, null, 10.0, null);
  world.drawer.setBox(50,50,-1,-50,-50,-1);
}

function InitEnvironmentMap()

{
	environmentTexture = gl.createTexture();
	gl.bindTexture( gl.TEXTURE_CUBE_MAP, environmentTexture );

	
	const url = 'https://webglfundamentals.org/webgl/resources/images/computer-history-museum/';
	const files = [

	  'pos-x.jpg',
	  'neg-x.jpg',
	  'pos-y.jpg',

	  'neg-y.jpg',
	  'pos-z.jpg',
	  'neg-z.jpg',

	];
	const faces = [
		gl.TEXTURE_CUBE_MAP_POSITIVE_X,

		gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
		gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
		gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,

		gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
		gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
	];


	var loaded = 0;
	for ( var i=0; i<6; ++i ) {
		gl.texImage2D( faces[i], 0, gl.RGBA, 128, 128, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );

		const img = new Image();
		img.crossOrigin = "anonymous";
		img.face = faces[i];

		img.onload = function() {
			gl.bindTexture( gl.TEXTURE_CUBE_MAP, environmentTexture );
			gl.texImage2D( this.face, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this );

			loaded++;
			if ( loaded == 6 ) {
				gl.generateMipmap(gl.TEXTURE_CUBE_MAP);

				DrawScene();
			}
		};

		img.src = url + files[i];
	}
	gl.texParameteri( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR );

}

// Called once to initialize
function InitWebGL()
{
	// Initialize the WebGL canvas

	canvas = document.getElementById("canvas");
	canvas.oncontextmenu = function() {return false;};
	gl = canvas.getContext("webgl", {antialias: false, depth: true});	// Initialize the GL context

	if (!gl) {
		alert("Unable to initialize WebGL. Your browser or machine may not support it.");
		return;

	}
	
	// Initialize settings

	gl.clearColor(0,0,0,0);
	gl.enable(gl.DEPTH_TEST);
	
	InitEnvironmentMap();		

  background.init();

  UpdateCanvasSize();
	
  InitScene();

}

// Called every time the window size is changed.
function UpdateCanvasSize()
{

	canvas.style.width  = "100%";
	canvas.style.height = "100%";
	const pixelRatio = window.devicePixelRatio || 1;

	canvas.width  = pixelRatio * canvas.clientWidth;
	canvas.height = pixelRatio * canvas.clientHeight;
	const width  = (canvas.width  / pixelRatio);

	const height = (canvas.height / pixelRatio);
	canvas.style.width  = width  + 'px';
	canvas.style.height = height + 'px';

	gl.viewport( 0, 0, canvas.width, canvas.height );
	UpdateProjectionMatrix();
}

function UpdateProjectionMatrix()
{

	const fov = 60;
	var r = canvas.width / canvas.height;
	var n = 0.1;

	const min_n = 0.001;
	if ( n < min_n ) n = min_n;
	var f = transZmax*100;

	var ff = Math.PI * fov / 180;
	var tant_2 = Math.tan( ff/2 );
	var s = 1 / tant_2;

	perspectiveMatrix = [
		s/r, 0, 0, 0,
		0, s, 0, 0,

		0, 0, -(n+f)/(f-n), -1,
		0, 0, -2*n*f/(f-n), 0
	];

	
	screenQuad.init(fov,(n+f)/2);
	background.updateProj();

}

function GetTrans()
{

	function dot(a,b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }

	var cz = Math.cos( viewRotZ );

	var sz = Math.sin( viewRotZ );
	var cx = Math.cos( viewRotX );
	var sx = Math.sin( viewRotX );


	var z = [ cx*sz, -cx*cz, sx ];
	var c = [ z[0]*transZ, z[1]*transZ, z[2]*transZ ];	

	var xlen = Math.sqrt( z[0]*z[0] + z[1]*z[1] );
	var x = [ -z[1]/xlen, z[0]/xlen, 0 ];
	var y = [ z[1]*x[2] - z[2]*x[1], z[2]*x[0] - z[0]*x[2], z[0]*x[1] - z[1]*x[0] ];

	
	var worldToCam = [
		x[0], y[0], z[0], 0,

		x[1], y[1], z[1], 0,
		x[2], y[2], z[2], 0,
		-dot(x,c), -dot(y,c), -dot(z,c), 1,

	];
	var camToWorld = [
		x[0], x[1], x[2], 0,

		y[0], y[1], y[2], 0,
		z[0], z[1], z[2], 0,
		c[0], c[1], c[2], 1

	];
	return { camToWorld:camToWorld, worldToCam:worldToCam };
}

// This is the main function that handled WebGL drawing
function DrawScene()

{
	gl.flush();

	// Clear the screen and the depth buffer.
	gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

  var trans = GetTrans();
  var mvp = MatrixMult( perspectiveMatrix, trans.worldToCam );

	// Rasterization
	background.draw( trans );
  world.setPosition(mvp);
	world.drawWorld();


}

// This is a helper function for compiling the given vertex and fragment shader script ids into a program.
function InitShaderProgramFromScripts( vs, fs )
{
	return InitShaderProgram( document.getElementById(vs).text, document.getElementById(fs).text );	

}

// This is a helper function for compiling the given vertex and fragment shader source code into a program.
function InitShaderProgram( vsSource, fsSource )
{
	const vs = CompileShader( gl.VERTEX_SHADER,   vsSource );

	const fs = CompileShader( gl.FRAGMENT_SHADER, fsSource );

	if ( ! vs || ! fs ) return null;

	
	const prog = gl.createProgram();
	gl.attachShader(prog, vs);

	gl.attachShader(prog, fs);
	gl.linkProgram(prog);


	if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
		alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(prog));
		return null;

	}
	return prog;
}

// This is a helper function for compiling a shader, called by InitShaderProgram().
function CompileShader( type, source )

{
	const shader = gl.createShader(type);
	gl.shaderSource(shader, source);

	gl.compileShader(shader);
	if (!gl.getShaderParameter( shader, gl.COMPILE_STATUS) ) {
		alert('An error occurred compiling shader:\n' + gl.getShaderInfoLog(shader));

		gl.deleteShader(shader);
		return null;
	}

	return shader;
}

// Multiplies two matrices and returns the result A*B.
// The arguments A and B are arrays, representing column-major matrices.
function MatrixMult( A, B )

{
	var C = [];
	for ( var i=0; i<4; ++i ) {

		for ( var j=0; j<4; ++j ) {
			var v = 0;
			for ( var k=0; k<4; ++k ) {

				v += A[j+4*k] * B[k+4*i];
			}
			C.push(v);

		}
	}
	return C;

}

window.onload = function() {

	InitWebGL();
	canvas.zoom = function( s ) {
		transZ *= s/canvas.height + 1;

		if ( transZ < transZmin ) transZ = transZmin;
		if ( transZ > transZmax ) transZ = transZmax;
		UpdateProjectionMatrix();

		DrawScene();
	}
	canvas.onwheel = function() { canvas.zoom(0.3*event.deltaY); }

	canvas.onmousedown = function() {
		var cx = event.clientX;
		var cy = event.clientY;

		if ( event.ctrlKey ) {
			canvas.onmousemove = function() {
				canvas.zoom(5*(event.clientY - cy));

				cy = event.clientY;
			}
		} else {

			canvas.onmousemove = function() {
				viewRotZ += (cx - event.clientX)/canvas.width*5;
				viewRotX -= (cy - event.clientY)/canvas.height*5;

				cx = event.clientX;
				cy = event.clientY;
				const eps = 0.01;

				if ( viewRotX < -0.1 ) viewRotX = -0.1;
				if ( viewRotX > Math.PI/2 - eps ) viewRotX = Math.PI/2 - eps;
				UpdateProjectionMatrix();

				DrawScene();
			}
		}

	}
	canvas.onmouseup = canvas.onmouseleave = function() {
		canvas.onmousemove = null;

	}
	
	DrawScene();

};

function WindowResize()

{
	UpdateCanvasSize();
	DrawScene();

}

function UseEnvironmentMap( param )

{
	gl.bindTexture( gl.TEXTURE_CUBE_MAP, param.checked ? environmentTexture : null );
	DrawScene();

}


function NewScene()
{
	InitScene();
	DrawScene();
}


///////////////////////////////////////////////////////////////////////////////////
</script>

<style>
html {
	color: white;
	background-color: black;
	font-family: Arial;
	overflow: hidden;
}
body {
	padding: 0;
	margin: 0;
}
input[type=checkbox], label {
	cursor: hand;
}
input[type=range] {
	width: 100%;
}
canvas {
	display: block;
	position: absolute;
	top:  0;
	left: 0;
	width:  100%;
	height: 100%;
}
#canvas-div {
	position: relative;
	width: 100%;
	height: 100%;
}
#controls-div {
	background-color: rgba(0,0,0,0.5);
	position: absolute;
	right: 1em;
	top: 1em;
	width: 18em;
}
#controls {
	padding: 1em;
}
.control {
	padding: 0.2em;
	clear: both;
}
.val {
	float: right;
	text-align: right;
}
.value {
	margin-right: 0.5em;
}
.btn {
	width: 100%;
}
#buttons {
	position: absolute;
	right: 0;
	top: 0;
}
#buttons input[type=button] {
	background-color: rgba(80,80,80,0.5);
	color: #aaa;
	font-size: 70%;
	outline: none;
}
</style>

</head>
<body onresize="WindowResize()">
<div id="canvas-div"><canvas id="canvas"></canvas></div></div>
</div>
</div>
</div>
</body>
</html>
